# 文件系统

## 文件权限与归属

Linux 系统使用了不同的字符来区分文件，常见的字符如下:

- -：普通文件
- d：目录文件
- l：链接文件
- b：块设备文件
- c：字符设备文件
- p：管道文件

在 Linux 系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的**可读（r）**、**可写（w）**、**可执行（x）**等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。

目录文件的权限设置。对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。

文件的读、写、执行权限可以简写为 **rwx**，亦可分别用数字 4、2、1 来表示，文件所有者，所属组及其他用户权限之间无关联。

| 权限分配 | 文件所有者 | 文件所属组 | 其他用户   |
| -------- | ---------- | ---------- | ---------- |
| 权限项   | 读 写 执行 | 读 写 执行 | 读 写 执行 |
| 字符表示 | r w x      | r w x      | r w x      |
| 数字表示 | 4 2 1      | 4 2 1      | 4 2 1      |

文件权限的数字法表示基于字符表示（rwx）的权限计算而来，其目的是简化权限的表示。例如，若某个文件的权限为 7 则代表可读、可写、可执行（4+2+1）；若权限为 6 则代表可读、可写（4+2）。

看这样一个例子。现在有这样一个文件，其所有者拥有可读、可写、可执行的权限，其文件所属组拥有可读、可写的权限；而且其他人只有可读的权限。那么，这个文件的权限就是 rwxrw-r--，数字法表示即为 764。

## 文件的特殊权限

### SUID

SUID 是一种对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）。例如，所有用户都可以执行 passwd 命令来修改自己的用户密码，而用户密码保存在 /etc/shadow 文件中。仔细查看这个文件就会发现它的默认权限是 000，也就是说除了 root 管理员以外，所有用户都没有查看或编辑该文件的权限。但是，在使用 passwd 命令时如果加上 SUID 特殊权限位，就可让普通用户临时获得程序所有者的身份，把变更的密码信息写入到 shadow 文件中。

查看 passwd 命令属性时发现所有者的权限由 rwx 变成了 rws，其中 x 改变成 s 就意味着该文件被赋予了 SUID 权限。

那么如果原本的权限是 rw-呢？如果原先权限位上没有 x 执行权限，那么被赋予特殊权限后将变成大写的 S。

### SGID

SGID 主要实现如下两种功能：

- 让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）；
- 在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。

```shell
[root@linux ~]# cd /tmp
[root@linux tmp]# mkdir testdir
[root@linux tmp]# ls -ald testdir/
drwxr-xr-x. 2 root root 6 Feb 11 11:50 testdir/
[root@linux tmp]# chmod -Rf 777 testdir/
[root@linux tmp]# chmod -Rf g+s testdir/
[root@linux tmp]# ls -ald testdir/
drwxrwsrwx. 2 root root 6 Feb 11 11:50 testdir/
```

在使用上述命令设置好目录的 777 权限（确保普通用户可以向其中写入文件），并为该目录设置了 SGID 特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：

```shell
[root@linux tmp]# su - testuesr
Last login: Wed Feb 11 11:49:16 CST 2017 on pts/0
[testuesr@linux ~]$ cd /tmp/testdir/
[testuesr@linux testdir]$ echo "baidu.com" > test
[testuesr@linux testdir]$ ls -al test
-rw-rw-r--. 1 testuesr root 15 Feb 11 11:50 test 
```

### chmod 命令

用来设置文件或目录的权限，格式：

```shell
chmod [参数] 权限 文件或目录名称
```

-R 或 --recursive 　  #递归处理，将指定目录下的所有文件及子目录一并处理

<访问者>+<权限设置> 　  #开启权限范围的文件或目录的该项权限设置。

<访问者>-<权限设置> 　  #关闭权限范围的文件或目录的该项权限设置。

<访问者>=<权限设置> 　  #指定权限范围的文件或目录的该项权限设置。

+t                   #设置目录文件的沾滞位

```shell
chmod 760 test

ls -l
# -rw-r--r-- 1 root root    0 Apr 10 16:24 test1.c

chmod u+x test1.c
ls -l
# -rwxr--r-- 1 root root    0 Apr 10 16:24 test1.c

chmod o-r test1.c 
ls -l
# -rwxr----- 1 root root    0 Apr 10 16:24 test1.c

chmod a=w test1.c 
ls -l
# --w--w--w- 1 root root    0 Apr 10 16:24 test1.c

chmod 777 test1.c 
ls -l
# -rwxrwxrwx 1 root root    0 Apr 10 16:24 test1.c
```

chmod +t 选项

当在一个目录中，想要其它用户能够创建文件并且只能删除自己的文件的时候，就需要靠沾滞位来实现。

### chown 命令

设置文件或目录的所有者和所属组，格式：

```shell
chown [参数] 所有者:所属组 文件或目录名称
```

chmod 和 chown 命令是用于修改文件属性和权限的最常用命令，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数-R 来表示递归操作，即对目录内所有的文件进行整体操作。

### SBIT（Sticky Bit）特殊权限位

SBIT 也可以称之为特殊权限位之粘滞位。SBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了 SBIT 粘滞位权限后，那么该目录
中的文件就只能被其所有者执行删除操作了。

与前面所讲的 SUID 和 SGID 权限显示方法不同，当目录被设置 SBIT 特殊权限位后，文件的其他人权限部分的 x 执行权限就会被替换成 t 或者 T，原本有 x 执行权限则会写成 t，原
本没有 x 执行权限则会被写成 T。

要是也想对其他目录来设置 SBIT 特殊权限位，用 chmod 命令就可以了。对应的参数 **o+t** 代表设置 SBIT 粘滞位权限：

## 文件的隐藏属性

### chattr 命令

chattr 命令用于设置文件的隐藏权限，格式：

```shell
chattr [参数] 文件
```

如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“**+参数**”，如果想要把某个隐藏功能移出文件，则需要追加“**-参数**”。chattr 命令中可供选择的隐藏权限参数非常丰富。

| 参数 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 |
| a    | 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）     |
| S    | 文件内容在变更后立即同步到硬盘（sync）                       |
| s    | 彻底从硬盘中删除，不可恢复（用 0 填充原文件所在硬盘区域）    |
| A    | 不再修改这个文件或目录的最后访问时间（atime）                |
| b    | 不再修改文件或目录的存取时间                                 |
| D    | 检查压缩文件中的错误                                         |
| d    | 使用 dump 命令备份时忽略本文件/目录                          |
| c    | 默认将文件或目录进行压缩                                     |
| u    | 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复         |
| t    | 让文件系统支持尾部合并（tail-merging）                       |
| x    | 可以直接访问压缩文件中的内容                                 |

 ### lsattr 命令

用于显示文件的隐藏权限，格式：

```shell
lsattr [参数] 文件
```

## 文件访问控制列表

如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。

通俗来讲，基于普通文件或目录设置 ACL 其实就是针对指定
的用户或用户组设置文件或目录的操作权限。另外，如果针对某个目录设置了 ACL，则目录中的文件会继承其 ACL；若针对文件设置了 ACL，则文件不再继承其所在目录的 ACL。

### setfacl 命令

用于管理文件的 ACL 规则，格式：

```shell
setfacl [参数] 文件名称
```

文件的 ACL 提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制，使用 setfacl 命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。其中，针对**目录文件**需要使用 **-R** 递归参数；针对**普通文件**则使用 **-m** 参数；如果想要**删除**某个文件的 ACL，则可以使用 **-b** 参数。

常用的 ls 命令是看不到 ACL 表信息的，但是却可以看到文件的权限最后一个点（.）变成了加号（+），这就意味着该文件已经设置了 ACL 了。

### getfacl 命令

getfacl 命令用于显示文件上设置的 ACL 信息，格式：

```shell
getfacl 文件名称
```

## su 命令与 sudo 服务

### su 命令

su 命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从 root 管理员切换至普通用户。

```shell
su - testuser
```

su 命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。**强烈建议在切换用户身份时添加这个减号**（-）。

当从 root 管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成 root 管理员就需要进行密码验证了；这也是一个必要的安全检查。

### sudo 命令

sudo 命令用于给普通用户提供额外的权限来完成原本 root 管理员才能完成的任务，格式：

```shell
sudo [参数] 命令名称
```

| 参数 | 作用                                                     |
| ---- | -------------------------------------------------------- |
| -h   | 列出帮助信息                                             |
| -l   | 列出当前用户可执行的命令                                 |
| -u   | 用户名或 UID 值 以指定的用户身份执行命令                 |
| -k   | 清空密码的有效时间，下次执行 sudo 时需要再次进行密码验证 |
| -b   | 在后台执行指定的命令                                     |
| -p   | 更改询问密码的提示语                                     |

sudo 命令具有如下功能：

- 限制用户执行指定的命令

- 记录用户执行的每一条命令

- 配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数

- 验证密码的后 5 分钟内（默认值）无须再让用户再次验证密码

当然，如果担心直接修改配置文件会出现问题，则可以使用 sudo 命令提供的 visudo 命令来配置用户权限。这条命令在配置用户权限时将禁止多个用户同时修改 sudoers 配置文件，还
可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错。

只有 root 管理员才可以使用 visudo 命令编辑 sudo 服务的配置文件。

